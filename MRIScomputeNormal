int
MRIScomputeNormals(MRI_SURFACE *mris)
{
  long seed;
  int  k, i ;

  /* Control the random seed so that MRIScomputeNormals() always does
     the same thing, otherwise it changes the xyz of the surface if
     it finds degenerate normals. */
  seed = getRandomSeed();
  setRandomSeed(1234);

  i = 0 ;

#if 0
  if (mris->status == MRIS_PLANE)
  {
    mrisComputeBoundaryNormals(mris);
    mrisSmoothBoundaryNormals(mris,10);
  }
#endif

#ifdef HAVE_OPENMP
#pragma omp parallel for
#endif
  for (k=0; k<mris->nfaces; k++) 
  {
    FACE *f ;
    int  n ;
    if (mris->faces[k].ripflag)
    {
      f = &mris->faces[k];
      for (n=0; n<VERTICES_PER_FACE; n++)
      {
        mris->vertices[f->v[n]].border = TRUE;
      }
    }
  }

#ifdef HAVE_OPENMP
#pragma omp parallel for reduction(+:i) schedule(static,1)
#endif
  for (k=0; k<mris->nvertices; k++) 
  {
    VERTEX    *v ;
    float     norm[3],snorm[3], len ;
    int       n, num ;

    v = &mris->vertices[k];
    if (!v->ripflag)
    {
      snorm[0]=snorm[1]=snorm[2]=0;
      v->area = 0;

      for (num = n=0; n<v->num; n++) if (!mris->faces[v->f[n]].ripflag)
        {
          num++ ;
          mrisNormalFace(mris, v->f[n] , (int)v->n[n] , norm);
          snorm[0] += norm[0];
          snorm[1] += norm[1];
          snorm[2] += norm[2];

          /* Note: overestimates area by *2 !! */
          v->area += mrisTriangleArea(mris, v->f[n], (int)v->n[n]);
        }
      if (!num)
        continue ;

      mrisNormalize(snorm);

      if (fix_vertex_area)
        v->area /= 3.0 ;
      else
        v->area /= 2.0 ;

      if (v->origarea<0)        /* has never been set */
        v->origarea = v->area;

      len = sqrt(snorm[0]*snorm[0] + snorm[1]*snorm[1] + snorm[2]*snorm[2]) ;
      if (!FZERO(len))
      {
        v->nx = snorm[0];
        v->ny = snorm[1];
        v->nz = snorm[2];
        i = 0 ;
      }
      else
      {
        if (i++ > 5) continue ;

	if(Gdiag & DIAG_SHOW && DIAG_VERBOSE_ON)
	  printf("vertex %d: i=%d, degenerate normal, seed=%ld, nc=%ld, fixing\n", k,i,getRandomSeed(),getRandomCalls()) ;

        if ((mris->status == MRIS_SPHERICAL_PATCH ||
             mris->status == MRIS_PARAMETERIZED_SPHERE ||
             mris->status == MRIS_SPHERE) && DIAG_VERBOSE_ON)
          fprintf(stderr, "vertex %d: degenerate normal\n", k) ;

        v->x += (float)randomNumber(-RAN, RAN) ;
        v->y += (float)randomNumber(-RAN, RAN) ;
        /* normal is always (0,0,+-1) anyway */
        if (mris->status == MRIS_PLANE || mris->status == MRIS_CUT)
        {
          v->nx = v->ny = 0.0f ;
          v->nz = 1.0f ;
          continue ;
        }

        v->z += (float)randomNumber(-RAN, RAN) ;
        for (n=0; n<v->vnum; n++) /*if (!mris->faces[v->f[n]].ripflag)*/
        {
	  if(Gdiag & DIAG_SHOW && DIAG_VERBOSE_ON)
	    printf("   k=%5d %d nbr = %5d / %d\n",k,n,v->v[n],v->vnum);
          mris->vertices[v->v[n]].x += (float)randomNumber(-RAN, RAN) ;
          mris->vertices[v->v[n]].y += (float)randomNumber(-RAN, RAN) ;
          mris->vertices[v->v[n]].z += (float)randomNumber(-RAN, RAN) ;
        }
        k-- ;   /* recalculate the normal for this vertex */
      }
    }
  }
#if 0
  mris->vertices[0].nx = mris->vertices[0].ny = 0 ;
  mris->vertices[0].nz = mris->vertices[0].nz / fabs(mris->vertices[0].nz) ;
#endif

  setRandomSeed(seed); // restore
  return(NO_ERROR) ;
}
